
# EXPLOITATION LIBRARY
# [MxMxE] -> [MxE]
# [MxM] -> [M]


import numpy as np


def get_stationary_distribution(A):
    v,W = np.linalg.eig(A)  # Compute eigenvalues and eigenvectors
    eig1 = np.argmax(v)     # Get the index of the highest eigenvalue (=1)
    return W[:,eig1]/np.sum(W[:,eig1]) # Return the scaled eigenvector

def RC_3D(tensor):
    # [MxMxE] -> [MxE]
    matrix = np.zeros((tensor.shape[0],tensor.shape[2]))
    for i in range(0,tensor.shape[2]):
        n = get_stationary_distribution(tensor[:,:,i])
        matrix[:,i] = n
    return matrix

def RCT_3D(tensor):
    # [MxMxE] -> [MxE]
    matrix = np.zeros((tensor.shape[0],tensor.shape[2]))
    for i in range(0,tensor.shape[2]):
        n = get_stationary_distribution(tensor[:,:,i].T)
        matrix[:,i] = n
    return matrix

def RC_2D(matrix):
    # [MxM] -> [M]  
    return get_stationary_distribution(matrix)

def RCT_2D(matrix):
    # [MxM] -> [M]  
    return get_stationary_distribution(matrix.T)

def WA_3D(tensor,w=None):
    # [MxMxE] -> [MxE]
    return np.average(tensor,axis=0,weights=w)

def WA_2D(matrix,w=None):
    # [MxM] -> [M]
    return np.average(matrix,axis=0,weights=w)

def OWA_2D(matrix,w=None):
    # [MxM] -> [M]
    vector = np.zeros(matrix.shape[0])
    for i in range(0,matrix.shape[0]):
        n = np.average(np.sort(matrix[:,i]),weights=w)
        vector[i] = n
    return vector

def NF_3D(tensor):
    # [MxMxE] -> [MxE]
    matrix = np.zeros((tensor.shape[0],tensor.shape[2]))
    for i in range(0,tensor.shape[2]):
        n = NF_2D(tensor[:,:,i])
        matrix[:,i] = n
    return matrix

def NF_2D(matrix):
    # [MxM] -> [M]
    return (np.sum(matrix,axis=1) - np.sum(matrix,axis=0))

def NFT_3D(tensor):
    # [MxMxE] -> [MxE]
    matrix = np.zeros((tensor.shape[0],tensor.shape[2]))
    for i in range(0,tensor.shape[2]):
        n = NFT_2D(tensor[:,:,i])
        matrix[:,i] = n
    return matrix

def NFT_2D(matrix):
    # [MxM] -> [M]
    return (np.sum(matrix.T,axis=1) - np.sum(matrix.T,axis=0))


